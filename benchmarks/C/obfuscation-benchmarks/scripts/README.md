# Scripts for Obfuscation and Deobfuscation via Symbolic Execution

These scripts have been developed over the course of writing a series of
academic papers [1,2,3]. The following presents the steps to perform in order
to use these scripts:

### Collecting the un-obfuscated C files

1. Write one or more C programs that you want to obfuscate. Or you can use the programs from the various obfuscation benchmark directories on this repository.

2. Copy these programs inside a dedicated working directory.

### Obfuscating the C files

3. Copy the `step01-ollvm-obfuscate-all-programs-combos.sh` script into the folder where you want the files obfuscated by obfuscator-LLVM to be generated. Call this script using the path to the directory where the un-obfuscated files are located as the first argument and the location of the ollvm binary as the second argument. This script generates 9 different ollvm obfuscated versions of each un-obfuscated program, as described in [2]. Note that 6 of these programs are obfuscated with combinations of 2 obfuscation transformations.

4. Copy the `generate-obfuscated.sh` and `step02-tigress-obfuscate-all-programs-combos.sh` scripts to the directory, wehre you want the files obfuscated by Tigress to be generated. These scripts use the Tigress obfuscation tool to automatically obfuscate all the C files using various combinations of obfuscation transformations. Note that Tigress should be installed and available in your PATH. Check the function names parameter of Tigress in the `generate-obfuscated.sh` script. Fix it accordingly to the function name that you want to obfuscate inside of your C files. In a terminal run the following script without any arguments: `$./step02-tigress-obfuscate-all-programs-combos.sh`. This script calls the `generate-obfuscated.sh` script, which results in 30 different variants of obfuscated programs, as described in [2]. Note that 25 of the 30 programs are obfuscated using 2 layers of obfuscation.

5. In case you do not want to have 30 differnt versions of Tigress obfuscated programs, use the script entitled `step03-tigress-obfuscate-all-programs-single.sh` insted of the previous step. This script only generates 5 obfuscated versions of each program, each with exactly one different obfuscation transformations, like the set of programs used in [3].

### Deobfuscate programs via symbolic execution

6. To symbolically execute all programs using KLEE you should run the script entitled `step04-klee-symex-until-end.sh`, which takes the directory where all the LLVM bitcode files that should be deobfuscated are stored. Note this script assumes that you have KLEE installed and in your PATH.

7. If your programs are written such that they contain a path which is difficult to find (see "winning path" in [1,2,3]) and when the right input agrument is given to the program to enter this path, the string "You win!" is printed on standard output, then you can use the two scripts entitled `step05-klee-symex-until-win.sh` and `step06-angr-symex-until-win.sh` to symbolically execute all the programs until the point when the winning path is found.

### Predicting deobfuscation times

8. In [3] we collected 64 different metrics, which we used to build prediction models for deobfuscation times for the sybolic execution attack based on KLEE. Some of these metrics were extracted using the Unified Code Count (UCC) tool. We won't show how to install and use the UCC tool here. However, we show how to obtain a more interesting resource to extract SAT metrics. For this purpose we modified the Z3 solver source code to output an internal SAT instance in DIMACS form. For this purpose we used the `z3_dimacs.patch` file provided by Nuno Lopes. To automate the conversion of SMT instances generated by KLEE to SAT instances, we wrote a script entitled `step07-convert-smt-to-cnf.sh`

9. After obtaining all the metrics from UCC, SatGraf, KLEE, etc. we needed to load them in R before we could start building a prediciton model. Since we had a large number of files we wrote a script that could automate the loading process for some of these metrics. The script is entitled `step08-load-stats-of-tigress-generated-programs.r`

10. Once the metrics are loaded, we can start training using different machine learning (ML) algorithms. The R script for different ML algorithms is pretty much the same, except for a small change indicating the name of the ML algorithm. The script can be found in the file entitled `step09-train-and-test-prediction-models.r`

11. After the ML algorithms have finished training and testing. The testing results were plotted to indicate the accuracy of our prediction models. We plotted results with 0%, 4% and 10% of outliers removed. The scripts corresponding to these plots are entitled `step10-plot-error-{0,4,10}percent-of-outliers-removed.r`

## References

1. Banescu, S., Ochoa, M., & Pretschner, A. (2015, May). _A framework for measuring software obfuscation resilience against automated attacks_. In Proceedings of the 1st International Workshop on Software Protection (SPRO).
2. Banescu, S., Collberg, C., Ganesh, V., Newsham, Z., & Pretschner, A. (2016, December). _Code obfuscation against symbolic execution attacks_. In Proceedings of the 32nd Annual Conference on Computer Security Applications (ACSAC).
3. Banescu, S., Collberg, C., & Pretschner, A. (2017, August)._Predicting the Resilience of Obfuscated Code Against Symbolic Execution Attacks via Machine Learning_. In Proceedings of the 26th USENIX Security Symposium.
